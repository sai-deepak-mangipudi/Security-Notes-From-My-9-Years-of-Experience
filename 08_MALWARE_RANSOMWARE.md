# 08 - Malware & Ransomware Analysis
## Comprehensive Analysis Techniques, Ransomware Families, Detection & Response Guide

---

## Table of Contents
1. [Malware Categories & Characteristics](#malware-categories--characteristics)
2. [Static Analysis Techniques](#static-analysis-techniques)
3. [Dynamic Analysis Techniques](#dynamic-analysis-techniques)
4. [Code Analysis Fundamentals](#code-analysis-fundamentals)
5. [Ransomware Families Reference (2024-2026)](#ransomware-families-reference-2024-2026)
6. [Ransomware Staging Detection](#ransomware-staging-detection-t1490)
7. [Ransomware Response Playbook](#ransomware-response-playbook)
8. [IOC Types & Quality Hierarchy](#ioc-types--quality-hierarchy)
9. [YARA Rules Examples](#yara-rules-examples)
10. [Malware Analysis Workflow](#malware-analysis-workflow)
11. [Interview Questions](#interview-questions---malwareransomware)

---

## Malware Categories & Characteristics

### Primary Classification Matrix

```
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| Category            | Characteristics                                  | Propagation               | Primary Objective      |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| TROJANS                                                                                                                  |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| RAT                 | Full remote control, keylogging, screen capture  | Phishing, drive-by        | Persistent access      |
| Banking Trojan      | Web injection, form grabbing, MFA bypass         | Malspam, exploit kits     | Financial theft        |
| Downloader/Dropper  | Minimal footprint, fetches payloads              | Email attachments         | Payload delivery       |
| Info Stealer        | Credential harvesting, browser data, wallets     | Phishing, malvertising    | Data theft             |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| RANSOMWARE                                                                                                               |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| Crypto-Ransomware   | File encryption, RSA/AES hybrid                  | RDP, phishing, exploits   | Extortion              |
| Locker Ransomware   | System lockout, no encryption                    | Exploit kits              | Extortion              |
| Double Extortion    | Encrypt + exfiltrate + leak threat               | Access brokers            | Extortion + data sale  |
| Triple Extortion    | Above + DDoS + customer notification             | Targeted intrusion        | Maximum pressure       |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| SELF-PROPAGATING                                                                                                         |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| Worm                | Network propagation, no user action needed       | Exploits, shares          | Spread + payload       |
| Botnet Agent        | C2-controlled, DDoS capable, modular             | Exploits, other malware   | Resource abuse         |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| PERSISTENCE/STEALTH                                                                                                      |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| Rootkit             | Kernel/user-mode hooks, hides processes/files    | Bundled with malware      | Concealment            |
| Bootkit             | MBR/VBR/UEFI infection, survives OS reinstall    | Physical/exploit          | Persistent stealth     |
| Fileless            | Memory-only, LOLBins, registry persistence       | Exploits, macros          | Evasion                |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| DESTRUCTIVE                                                                                                              |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| Wiper               | Data destruction, MBR overwrite, no recovery     | Targeted deployment       | Destruction            |
| Logic Bomb          | Time/event-triggered destruction                 | Insider placement         | Sabotage               |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| RESOURCE ABUSE                                                                                                           |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
| Cryptominer         | CPU/GPU hijacking, persistence-focused           | Exploits, bundled         | Cryptocurrency         |
| Proxy Malware       | Traffic relay, residential proxy networks        | Bundled software          | Anonymization          |
+---------------------+--------------------------------------------------+---------------------------+------------------------+
```

### Modern Malware Trends (2024-2026)

```
EVOLUTION PATTERNS:
├── Rust/Go Adoption
│   ├── Cross-platform compilation
│   ├── Harder to reverse engineer
│   ├── Better evasion of signature-based detection
│   └── Examples: BlackCat (Rust), BianLian (Go)
│
├── EDR Evasion Techniques
│   ├── Direct syscalls (bypassing ntdll hooks)
│   ├── Unhooking (restoring original ntdll)
│   ├── BYOVD (Bring Your Own Vulnerable Driver)
│   ├── Kernel callback removal
│   └── ETW patching/blinding
│
├── Living-off-the-Land Binaries (LOLBins)
│   ├── certutil, mshta, regsvr32, rundll32
│   ├── wmic, msiexec, cmstp, msxsl
│   └── PowerShell constrained language mode bypass
│
├── Supply Chain Vectors
│   ├── Compromised software updates
│   ├── Typosquatting packages (npm, PyPI)
│   ├── Compromised development tools
│   └── CI/CD pipeline injection
│
└── AI-Enhanced Capabilities
    ├── Polymorphic code generation
    ├── Context-aware social engineering
    ├── Automated vulnerability discovery
    └── Adaptive evasion
```

---

## Static Analysis Techniques

### File Identification & Hashing

```bash
# Multi-algorithm hashing
sha256sum malware.exe
sha1sum malware.exe
md5sum malware.exe

# SSDEEP fuzzy hash (similarity matching)
ssdeep malware.exe
ssdeep -m known_malware.ssdeep malware.exe  # Compare against database

# TLSH (Trend Micro Locality Sensitive Hash)
tlsh -f malware.exe

# Import hash (imphash) - Python pefile
python3 -c "import pefile; pe=pefile.PE('malware.exe'); print(pe.get_imphash())"

# Rich header hash
python3 -c "import pefile; pe=pefile.PE('malware.exe'); print(pe.get_rich_header_hash())"

# File type identification
file malware.exe
TrID malware.exe           # Detailed type detection
DIE (Detect It Easy)       # Packer/compiler detection
```

### PE (Portable Executable) Analysis

```
PE HEADER STRUCTURE:
├── DOS Header
│   └── e_lfanew → Offset to PE signature
├── PE Signature ("PE\0\0")
├── File Header (COFF)
│   ├── Machine (x86: 0x14c, x64: 0x8664)
│   ├── NumberOfSections
│   ├── TimeDateStamp ← Compile time (often faked)
│   ├── PointerToSymbolTable
│   └── Characteristics (DLL, executable, etc.)
├── Optional Header
│   ├── Magic (PE32: 0x10b, PE32+: 0x20b)
│   ├── AddressOfEntryPoint ← Start of execution
│   ├── ImageBase (preferred load address)
│   ├── SectionAlignment / FileAlignment
│   ├── Subsystem (GUI: 2, Console: 3)
│   └── Data Directories (16 entries)
│       ├── Export Table
│       ├── Import Table ← Critical for analysis
│       ├── Resource Table
│       ├── Exception Table
│       ├── Certificate Table ← Digital signature
│       ├── Base Relocation Table
│       ├── Debug Directory
│       ├── TLS Table ← Anti-debugging location
│       ├── Load Config ← Security features (CFG, etc.)
│       ├── Bound Import
│       ├── IAT (Import Address Table)
│       ├── Delay Import
│       ├── CLR Runtime Header (.NET)
│       └── Reserved
└── Section Headers
    └── .text, .data, .rdata, .rsrc, .reloc, etc.

PE ANALYSIS TOOLS:
├── pestudio (Windows, free, comprehensive)
├── PE-bear (Cross-platform, modern UI)
├── CFF Explorer (Detailed header editing)
├── pefile (Python library)
├── dumpbin /all malware.exe (Visual Studio)
└── objdump -x malware.exe (Linux)
```

### Suspicious PE Characteristics

```
RED FLAGS IN PE ANALYSIS:

Section Anomalies:
├── Unusual section names: UPX0, .packed, .vmp0, .themida
├── High entropy sections (>7.0) → Encrypted/compressed
├── Executable + Writable sections → Self-modifying code
├── Section size on disk vs memory mismatch → Unpacking
├── Entry point outside .text section
└── Very small .text with large other sections

Import Analysis:
├── Very few imports → Packed or dynamic resolution
├── LoadLibrary + GetProcAddress only → API hiding
├── No imports at all → Shellcode or packed

Timestamp Analysis:
├── Future dates → Fake timestamp
├── Very old dates (1970s) → Zeroed or default
├── Mismatch with other artifacts → Timestomping

Resource Analysis:
├── Embedded executables in resources
├── Encrypted blobs in resources
├── Version info mismatch with file properties
└── Unusual resource types (custom numeric IDs)

Signature Analysis:
├── Invalid/revoked certificate
├── Certificate from compromised CA
├── Self-signed certificate
├── Signature timestamp vs compile time mismatch
└── Catalog-signed vs embedded signature
```

### String Analysis

```bash
# Basic string extraction
strings -a malware.exe                    # All strings
strings -a -el malware.exe                # Unicode (little-endian)
strings -a -eb malware.exe                # Unicode (big-endian)

# FLOSS (FireEye Labs Obfuscated String Solver)
floss malware.exe                         # Extracts obfuscated strings
floss -n 6 malware.exe                    # Minimum length 6
floss --no-static-strings malware.exe     # Only decoded strings

# String patterns to search for
strings malware.exe | grep -iE "(http|https|ftp)://"           # URLs
strings malware.exe | grep -iE "([0-9]{1,3}\.){3}[0-9]{1,3}"   # IPs
strings malware.exe | grep -iE "\.(dll|exe|bat|ps1|vbs)$"      # File refs
strings malware.exe | grep -iE "(cmd|powershell|wscript)"      # Execution
strings malware.exe | grep -iE "(password|credential|token)"   # Sensitive
strings malware.exe | grep -iE "(bitcoin|monero|wallet)"       # Crypto
strings malware.exe | grep -iE "HKEY_|HKLM|HKCU"               # Registry

SUSPICIOUS STRING PATTERNS:
├── Base64-encoded blobs (long alphanumeric strings)
├── XOR keys (repeated short patterns)
├── C2 domains/IPs
├── Ransom note text
├── Mutex names (Global\, Local\)
├── Named pipes (\\.\pipe\)
├── Windows API names (especially sensitive ones)
├── Registry paths for persistence
├── Debug/PDB paths (reveals dev environment)
└── Email addresses, Bitcoin/Monero addresses
```

### Suspicious API Imports Reference

```
PROCESS MANIPULATION:
├── CreateProcess, CreateProcessAsUser           → Process creation
├── CreateRemoteThread, NtCreateThreadEx         → Remote code execution
├── WriteProcessMemory, NtWriteVirtualMemory     → Memory injection
├── VirtualAllocEx, NtAllocateVirtualMemory      → Remote memory allocation
├── OpenProcess, NtOpenProcess                   → Process handle acquisition
├── QueueUserAPC, NtQueueApcThread               → APC injection
├── SetThreadContext, NtSetContextThread         → Thread hijacking
├── NtUnmapViewOfSection                         → Process hollowing
└── RtlCreateUserThread                          → Stealthier thread creation

MEMORY MANIPULATION:
├── VirtualAlloc, VirtualProtect                 → Memory allocation/protection
├── HeapCreate, HeapAlloc                        → Heap manipulation
├── NtProtectVirtualMemory                       → Direct syscall variant
└── RtlMoveMemory, memcpy                        → Memory copy (shellcode)

CODE EXECUTION:
├── LoadLibrary, LdrLoadDll                      → DLL loading
├── GetProcAddress, LdrGetProcedureAddress       → Dynamic API resolution
├── ShellExecute, WinExec                        → Command execution
├── CreateThread, _beginthread                   → Local thread creation
└── CallWindowProc, EnumWindows                  → Callback abuse

PERSISTENCE:
├── RegSetValueEx, RegCreateKeyEx                → Registry modification
├── CreateService, StartService                  → Service creation
├── SetWindowsHookEx                             → Hook installation
├── CreateFileMapping, MapViewOfFile             → Shared memory
└── SHGetFolderPath                              → User folder location

CREDENTIAL ACCESS:
├── CredEnumerate, CredRead                      → Credential vault
├── CryptUnprotectData                           → DPAPI decryption
├── LsaRetrievePrivateData                       → LSA secrets
├── SamConnect, SamEnumerateUsers                → SAM database
├── OpenProcessToken, AdjustTokenPrivileges      → Token manipulation
└── LookupPrivilegeValue, LookupAccountSid       → Privilege lookup

NETWORK:
├── socket, connect, send, recv                  → Winsock
├── InternetOpen, HttpOpenRequest, HttpSendRequest  → WinINet
├── WinHttpOpen, WinHttpConnect                  → WinHTTP
├── URLDownloadToFile                            → Direct download
├── WSAStartup, getaddrinfo, gethostbyname       → DNS resolution
└── DnsQuery                                     → Direct DNS

ANTI-ANALYSIS:
├── IsDebuggerPresent, CheckRemoteDebuggerPresent → Debugger detection
├── NtQueryInformationProcess                    → ProcessDebugPort check
├── GetTickCount, QueryPerformanceCounter        → Timing checks
├── OutputDebugString                            → Debugger probe
├── NtSetInformationThread (ThreadHideFromDebugger) → Anti-debugging
├── FindWindow                                   → VM/sandbox detection
└── GetSystemInfo, GlobalMemoryStatusEx          → Environment fingerprint

CRYPTO:
├── CryptEncrypt, CryptDecrypt                   → Windows Crypto API
├── CryptAcquireContext, CryptCreateHash         → Crypto context
├── BCryptEncrypt, BCryptDecrypt                 → CNG (modern)
├── NCryptEncrypt, NCryptDecrypt                 → Key storage
└── CryptImportKey, CryptExportKey               → Key operations
```

### YARA Rule Basics for Static Analysis

```yara
rule Suspicious_PE_Characteristics
{
    meta:
        description = "Detects suspicious PE characteristics"
        author = "Security Team"
        date = "2026-02-24"

    condition:
        uint16(0) == 0x5A4D and  // MZ header
        (
            // High entropy in any section
            math.entropy(0, filesize) > 7.0 or

            // Small import table (likely packed)
            pe.number_of_imports < 5 or

            // Entry point in unusual section
            not pe.entry_point in (pe.sections[0].raw_data_offset ..
                pe.sections[0].raw_data_offset + pe.sections[0].raw_data_size)
        )
}

rule Packed_Executable_Indicators
{
    meta:
        description = "Generic packer detection"

    strings:
        $upx = "UPX!"
        $aspack = ".aspack"
        $themida = ".themida"
        $vmp = ".vmp0"
        $petite = ".petite"
        $mpress = ".MPRESS"

    condition:
        uint16(0) == 0x5A4D and any of them
}
```

---

## Dynamic Analysis Techniques

### Sandbox Environment Setup

```
ISOLATED ANALYSIS ENVIRONMENT:
├── Hardware
│   ├── Dedicated analysis machine (not VM for some samples)
│   ├── Air-gapped network or controlled routing
│   ├── Hardware write-blocker for disk analysis
│   └── Separate VLAN/physical network segment
│
├── Virtual Machine Configuration
│   ├── VMware Workstation/ESXi or VirtualBox
│   ├── Snapshot before each analysis
│   ├── Disable shared folders
│   ├── Disable clipboard sharing
│   ├── NAT or host-only networking
│   ├── Anti-VM detection countermeasures
│   └── Realistic user environment (documents, browser history)
│
├── Network Configuration
│   ├── INetSim - Simulate internet services
│   ├── FakeNet-NG - Network simulation
│   ├── Remnux as gateway/analysis system
│   ├── Burp Suite for HTTP/S inspection
│   └── Wireshark/tcpdump for packet capture
│
└── Analysis Tools (Pre-installed)
    ├── Process Monitor (ProcMon)
    ├── Process Explorer
    ├── Process Hacker
    ├── Regshot (registry diff)
    ├── API Monitor
    ├── x64dbg/OllyDbg
    ├── Noriben (automated analysis)
    └── Capture-BAT
```

### Behavioral Analysis Indicators

```
PROCESS ACTIVITY INDICATORS:

Process Creation:
├── cmd.exe /c <suspicious command>
├── powershell.exe with encoded commands (-enc, -e)
├── wscript.exe / cscript.exe executing scripts
├── mshta.exe loading remote HTA
├── regsvr32.exe /s /n /u /i:<url>
├── rundll32.exe with suspicious arguments
├── certutil.exe -urlcache -split -f <url>
└── Unusual parent-child relationships
    ├── Word/Excel → cmd/powershell (macro execution)
    ├── explorer.exe → direct malware launch
    ├── services.exe → unexpected children
    └── svchost.exe with wrong parent

Process Injection Detection:
├── VirtualAllocEx to remote process
├── WriteProcessMemory to remote process
├── CreateRemoteThread in another process
├── NtMapViewOfSection with SEC_IMAGE
├── SetThreadContext modification
├── QueueUserAPC to remote thread
└── Process hollowing sequence:
    1. CreateProcess (SUSPENDED)
    2. NtUnmapViewOfSection
    3. VirtualAllocEx
    4. WriteProcessMemory
    5. SetThreadContext
    6. ResumeThread

FILE SYSTEM INDICATORS:

Suspicious File Operations:
├── Drops to %TEMP%, %APPDATA%, %LOCALAPPDATA%
├── Creates hidden files (attrib +h)
├── Modifies system files
├── Creates files with double extensions
├── Mass file operations (ransomware)
├── Shadow copy deletion
├── Writes to startup folders
└── Creates scheduled tasks

Ransomware File Indicators:
├── File enumeration (FindFirstFile/FindNextFile)
├── Bulk file reading
├── Bulk file writing with new extensions
├── Ransom note creation (README.txt, etc.)
├── Encryption API calls (CryptEncrypt, BCrypt*)
└── Key file operations (storing/sending keys)

REGISTRY INDICATORS:

Persistence Locations:
├── HKCU\Software\Microsoft\Windows\CurrentVersion\Run
├── HKLM\Software\Microsoft\Windows\CurrentVersion\Run
├── HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
├── HKLM\SYSTEM\CurrentControlSet\Services
├── HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon
├── HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
└── HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects

Security Tampering:
├── Disabling Windows Defender (DisableAntiSpyware)
├── Modifying firewall rules
├── Disabling UAC
├── Tampering with security center
└── Modifying AMSI (AmsiEnable)

NETWORK INDICATORS:

C2 Communication Patterns:
├── Beaconing (regular interval connections)
├── DNS queries for suspicious domains
├── HTTP(S) to suspicious URLs
├── Unusual ports (high ports, non-standard)
├── Encrypted traffic on non-443 ports
├── Large data transfers (exfiltration)
├── Connection to known bad IPs
└── DGA (Domain Generation Algorithm) patterns

Protocol Indicators:
├── HTTP with suspicious User-Agent
├── HTTP POST with encoded/encrypted body
├── DNS TXT record queries (tunneling)
├── ICMP with data payload (tunneling)
├── Raw socket usage
└── Direct IP connections (no DNS)
```

### Commercial & Open Source Sandboxes

```
COMMERCIAL SANDBOXES:
├── VMRay
│   ├── Reputation-based detection bypass
│   ├── Hypervisor-level monitoring
│   └── Excellent for evasive malware
├── Joe Sandbox
│   ├── Comprehensive behavioral analysis
│   ├── Good YARA integration
│   └── Multiple OS support
├── Any.Run
│   ├── Interactive sandbox
│   ├── Real-time control
│   └── Good for manual investigation
├── Hybrid Analysis (HA)
│   ├── Falcon Sandbox backend
│   ├── Free tier available
│   └── Good community
└── Cuckoo Sandbox (Self-hosted)
    ├── Open source, customizable
    ├── Requires maintenance
    └── Good for private analysis

SANDBOX EVASION TECHNIQUES (Detection):
├── Time-based
│   ├── Sleep calls (Sleep, NtDelayExecution)
│   ├── GetTickCount/QueryPerformanceCounter checks
│   └── Time acceleration detection
├── Environment-based
│   ├── VM detection (registry, hardware)
│   ├── Sandbox artifacts (DLLs, processes)
│   ├── Username/computername checks
│   ├── MAC address vendor checks
│   └── Disk size/RAM checks
├── Behavior-based
│   ├── User interaction requirements
│   ├── Mouse movement detection
│   ├── Screen resolution checks
│   ├── Running process checks
│   └── Network connectivity requirements
└── Counter-sandbox Detection
    ├── Monitor for known sandbox processes
    ├── Check for analysis tools
    └── Detect hooking/instrumentation
```

### Automated Dynamic Analysis Script

```python
# Noriben-style analysis automation (conceptual)
"""
AUTOMATED ANALYSIS WORKFLOW:
1. Start monitoring tools
2. Take baseline snapshot
3. Execute sample
4. Wait for activity (with timeout)
5. Capture final state
6. Generate diff report
7. Extract IOCs
"""

# ProcMon filter for malware analysis
"""
PROCMON FILTER RECOMMENDATIONS:
Include:
├── Process Name contains <malware_name>
├── Operation is WriteFile
├── Operation is RegSetValue
├── Operation is TCP Connect
├── Operation is Process Create
└── Operation is Thread Create

Exclude:
├── Process Name is procmon.exe
├── Process Name is System
├── Path contains pagefile
├── Result is SUCCESS (for focused troubleshooting)
└── Operation is RegQueryValue (often noisy)
"""
```

---

## Code Analysis Fundamentals

### Disassembly Tools Comparison

```
DISASSEMBLERS/DECOMPILERS:
┌─────────────────┬─────────────────────────────────────────────────────────┐
│ Tool            │ Characteristics                                         │
├─────────────────┼─────────────────────────────────────────────────────────┤
│ IDA Pro         │ Industry standard, best analysis, expensive             │
│                 │ Hex-Rays decompiler, extensive plugins                  │
│                 │ Best for: Professional analysis, complex samples        │
├─────────────────┼─────────────────────────────────────────────────────────┤
│ Ghidra          │ NSA-developed, free, excellent decompiler               │
│                 │ Java-based, scriptable, collaborative features          │
│                 │ Best for: Budget-conscious, learning, scripting         │
├─────────────────┼─────────────────────────────────────────────────────────┤
│ Binary Ninja    │ Modern UI, good API, intermediate pricing               │
│                 │ Cloud collaboration, IL-based analysis                  │
│                 │ Best for: Automation, modern workflows                  │
├─────────────────┼─────────────────────────────────────────────────────────┤
│ Radare2/Cutter  │ Open source, command-line + GUI                         │
│                 │ Steep learning curve, very powerful                     │
│                 │ Best for: Linux users, CTFs, scripting                  │
├─────────────────┼─────────────────────────────────────────────────────────┤
│ x64dbg          │ Open source debugger for Windows                        │
│                 │ Plugin ecosystem, good for unpacking                    │
│                 │ Best for: Dynamic analysis, debugging                   │
├─────────────────┼─────────────────────────────────────────────────────────┤
│ dnSpy           │ .NET decompiler and debugger                            │
│                 │ Edit and recompile, excellent for .NET                  │
│                 │ Best for: .NET malware                                  │
├─────────────────┼─────────────────────────────────────────────────────────┤
│ JEB             │ Android/ARM specialist, also x86                        │
│                 │ Good decompiler, expensive                              │
│                 │ Best for: Mobile malware, ARM analysis                  │
└─────────────────┴─────────────────────────────────────────────────────────┘
```

### Anti-Analysis Techniques & Bypasses

```
DEBUGGER DETECTION:
┌──────────────────────────────────────┬─────────────────────────────────────┐
│ Technique                            │ Bypass                              │
├──────────────────────────────────────┼─────────────────────────────────────┤
│ IsDebuggerPresent()                  │ Patch return value, modify PEB      │
│ CheckRemoteDebuggerPresent()         │ Hook/patch function                 │
│ NtQueryInformationProcess            │ Return 0 for ProcessDebugPort       │
│   (ProcessDebugPort)                 │                                     │
│ NtQueryInformationProcess            │ Return 0                            │
│   (ProcessDebugFlags)                │                                     │
│ NtQueryInformationProcess            │ Return null handle                  │
│   (ProcessDebugObjectHandle)         │                                     │
│ PEB.BeingDebugged flag               │ Set to 0 in PEB                     │
│ PEB.NtGlobalFlag                     │ Clear debug flags (0x70)            │
│ Heap flags (ForceFlags)              │ Patch heap headers                  │
│ RDTSC timing checks                  │ Patch or use VM with TSC scaling    │
│ INT 2D                               │ Patch exception handler             │
│ Hardware breakpoint detection        │ Clear DR0-DR7 in context            │
│ Software breakpoint (0xCC scan)      │ Don't set BPs in scanned areas      │
│ OutputDebugString                    │ Return success                      │
│ CloseHandle(invalid)                 │ Don't break on exception            │
└──────────────────────────────────────┴─────────────────────────────────────┘

VM DETECTION:
┌──────────────────────────────────────┬─────────────────────────────────────┐
│ Technique                            │ Countermeasure                      │
├──────────────────────────────────────┼─────────────────────────────────────┤
│ Registry keys (VMware, VBox)         │ Delete/modify keys                  │
│ MAC address prefix                   │ Change MAC to real vendor           │
│ CPUID instruction                    │ Modify hypervisor response          │
│ Process names (vmtoolsd, etc.)       │ Rename/hide processes               │
│ File system artifacts                │ Remove VM tools files               │
│ Hardware strings (BIOS, disk)        │ Modify WMI responses                │
│ Red Pill (SIDT/SGDT)                 │ Use modern VMM (patched)            │
│ Timing-based                         │ Use bare metal or RDTSC masking     │
│ In/Out instruction (VMware)          │ Disable or patch                    │
│ ACPI tables                          │ Modify tables                       │
└──────────────────────────────────────┴─────────────────────────────────────┘

SANDBOX EVASION:
├── User interaction required (mouse clicks, scrolling)
├── Time delays (long sleeps)
├── Check for real user files (documents, browser history)
├── Network connectivity required
├── Specific geolocation
├── Domain-joined machine required
├── Specific software installed
└── Screen resolution/color depth checks
```

### Common Malware Patterns in Assembly

```asm
; API HASHING (GetProcAddress alternative)
; Malware hashes API names to avoid string detection
hash_api:
    xor     eax, eax           ; Clear accumulator
    xor     edx, edx
hash_loop:
    lodsb                      ; Load byte from ESI
    test    al, al             ; Check for null terminator
    jz      hash_done
    ror     edx, 13            ; Rotate right 13 (common hash)
    add     edx, eax           ; Add character
    jmp     hash_loop
hash_done:
    ; EDX now contains hash to compare against known values

; PROCESS INJECTION (CreateRemoteThread)
injection_sequence:
    ; 1. Get target process handle
    push    0                  ; bInheritHandle
    push    PROCESS_ALL_ACCESS
    push    target_pid
    call    OpenProcess        ; Returns handle in EAX
    mov     ebx, eax           ; Save handle

    ; 2. Allocate memory in target
    push    PAGE_EXECUTE_READWRITE
    push    MEM_COMMIT
    push    shellcode_size
    push    0                  ; lpAddress (let system choose)
    push    ebx                ; hProcess
    call    VirtualAllocEx
    mov     edi, eax           ; Save allocated address

    ; 3. Write shellcode
    push    0                  ; lpNumberOfBytesWritten
    push    shellcode_size
    push    offset shellcode
    push    edi                ; lpBaseAddress
    push    ebx                ; hProcess
    call    WriteProcessMemory

    ; 4. Execute
    push    0                  ; lpThreadId
    push    0                  ; dwCreationFlags
    push    0                  ; lpParameter
    push    edi                ; lpStartAddress
    push    0                  ; dwStackSize
    push    0                  ; lpThreadAttributes
    push    ebx                ; hProcess
    call    CreateRemoteThread

; XOR STRING DECRYPTION
decrypt_string:
    mov     esi, offset encrypted_string
    mov     edi, offset decrypted_buffer
    mov     ecx, string_length
    mov     al, xor_key
decrypt_loop:
    mov     bl, [esi]
    xor     bl, al
    mov     [edi], bl
    inc     esi
    inc     edi
    loop    decrypt_loop

; RC4 DECRYPTION (Common in malware)
; S-box initialization and PRGA
rc4_init:
    ; Initialize S-box (0-255)
    xor     eax, eax
init_sbox:
    mov     [esi+eax], al
    inc     al
    jnz     init_sbox
    ; Key scheduling algorithm follows...
```

### Ghidra Analysis Workflow

```
GHIDRA ANALYSIS STEPS:
1. Create new project
2. Import binary (File → Import)
3. Auto-analyze (accept defaults + aggressive instruction finding)
4. Navigate to entry point (Go → Program Entry Point)
5. Identify main() function
6. Rename functions as understood
7. Apply function signatures
8. Use decompiler view
9. Add comments and bookmarks
10. Export analysis/report

USEFUL GHIDRA SCRIPTS:
├── FindCrypt - Identify crypto constants
├── Yara - Apply YARA rules
├── SearchForStrings - Enhanced string search
├── FindUPX - Detect UPX packing
├── ResolveX86ConditionalConstants
└── Custom Python/Java scripts

GHIDRA SHORTCUTS:
├── G - Go to address
├── L - Rename (label)
├── ; - Add comment
├── D - Disassemble
├── C - Clear code/data
├── T - Set data type
├── F - Create function
├── X - Cross-references
└── Ctrl+Shift+E - Decompile
```

### Unpacking Packed Executables

```
COMMON PACKERS:
├── UPX (Ultimate Packer for eXecutables)
│   └── upx -d packed.exe -o unpacked.exe
├── Themida/WinLicense
│   └── Complex, requires manual unpacking or specialized tools
├── VMProtect
│   └── Virtualization-based, extremely difficult
├── ASPack
│   └── OEP finding + dump
├── PECompact
│   └── Similar to ASPack approach
├── MPRESS
│   └── Can often find OEP easily
└── Custom packers
    └── Requires full manual analysis

MANUAL UNPACKING WORKFLOW:
1. Load in debugger (x64dbg)
2. Find Original Entry Point (OEP)
   ├── Hardware breakpoint on ESP (pushad/popad)
   ├── Exception tracking
   ├── API breakpoints (GetProcAddress, VirtualProtect)
   └── Single-step through unpacking stub
3. Dump memory at OEP
   ├── Scylla (dump + IAT rebuild)
   ├── OllyDumpEx
   └── PE-sieve
4. Fix Import Address Table (IAT)
   ├── Scylla IAT Autosearch
   ├── ImpREC
   └── Manual reconstruction
5. Verify unpacked binary runs
6. Analyze clean binary

FINDING OEP TECHNIQUES:
├── ESP trick: bp on [ESP] after PUSHAD, run, hit at POPAD
├── Memory breakpoint on code section
├── Exception-based: trace exception handlers
├── API breakpoints: VirtualProtect changing .text permissions
└── Pattern recognition: JMP to unpacked code
```

---

## Ransomware Families Reference (2024-2026)

### LockBit 3.0 / LockBit Black

```
LOCKBIT 3.0 PROFILE:
├── Status: Most prolific ransomware (2023-2024), disrupted Feb 2024
├── Model: RaaS (Ransomware-as-a-Service)
├── Language: C/C++
├── Platforms: Windows, Linux (ESXi), macOS
├── Encryption: AES-256 + RSA-2048 (hybrid)
├── Extension: .lockbit, .HLJkNskOq (random)
├── Ransom Note: [random].README.txt

TECHNICAL CHARACTERISTICS:
├── Self-spreading via SMB and Group Policy
├── Embedded configuration (encrypted in PE resource)
├── Anti-analysis: API hashing, string encryption
├── Bug bounty program for vulnerabilities
├── StealBit data exfiltration tool
├── Multiple encryption modes (fast, intermittent, full)
├── UAC bypass via CMSTPLUA
└── Terminates security/backup processes

DETECTION INDICATORS:
├── Process: Creates multiple threads for encryption
├── File: Mass file renaming with random extension
├── Registry: Disables recovery options
├── Network: SMB lateral movement
├── Commands:
│   ├── vssadmin delete shadows /all /quiet
│   ├── wmic shadowcopy delete
│   ├── bcdedit /set {default} recoveryenabled No
│   └── netsh advfirewall set allprofiles state off

YARA SIGNATURE:
rule LockBit3_Ransomware {
    strings:
        $s1 = "LockBit 3.0" ascii wide
        $s2 = "Restore-My-Files.txt" ascii wide
        $s3 = { 4C 6F 63 6B 42 69 74 }  // "LockBit"
        $cfg = { 00 00 00 00 [4] 00 00 00 00 } // Config marker
        $mutex = "Global\\%s" ascii
    condition:
        uint16(0) == 0x5A4D and 3 of them
}

IOCs (SAMPLE):
├── Mutex: Global\{GUID}
├── Extension: .lockbit, random 9-char
├── Note: [random].README.txt
├── C2: Tor-based leak site
└── Tool: StealBit, Cobalt Strike
```

### BlackCat / ALPHV

```
BLACKCAT/ALPHV PROFILE:
├── Status: Major operator, law enforcement disruption Dec 2023
├── Model: RaaS with sophisticated affiliate program
├── Language: Rust (first major Rust ransomware)
├── Platforms: Windows, Linux, ESXi, ARM
├── Encryption: AES-128/256 + RSA-2048/4096
├── Extension: Random (7 chars), configurable
├── Ransom Note: RECOVER-[random]-FILES.txt

TECHNICAL CHARACTERISTICS:
├── Written in Rust for cross-platform + evasion
├── Highly configurable via JSON config
├── Access token required for execution
├── Embedded credentials for lateral movement
├── ESXi-specific variant (kills VMs)
├── PsExec, WMI for propagation
├── Data exfiltration via ExMatter tool
├── Searchable leak site with stolen data
└── Recovery key provable (negotiation tactic)

DETECTION INDICATORS:
├── Process: blackcat.exe, [random].exe
├── Command line: --access-token [token] --paths [paths]
├── File extension: Random 7 characters
├── Services: Terminates backup, AV, database services
├── Network: Tor for C2 and leak site
├── Commands:
│   ├── fsutil behavior set SymlinkEvaluation R2L:1
│   ├── reg add HKLM\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters
│   ├── vssadmin.exe delete shadows /all /quiet
│   └── wmic.exe shadowcopy delete

YARA SIGNATURE:
rule BlackCat_ALPHV {
    strings:
        $rust1 = "rust_panic" ascii
        $rust2 = ".rdata$zzzz" ascii
        $s1 = "access-token" ascii
        $s2 = "RECOVER-" ascii
        $s3 = "-FILES.txt" ascii
        $cfg = "\"config\":" ascii
    condition:
        uint16(0) == 0x5A4D and
        (all of ($rust*) and 2 of ($s*))
}

IOCs (SAMPLE):
├── Config: JSON embedded or command line
├── Extension: 7 random alphanumeric
├── Tor Sites: Multiple .onion addresses
├── User-Agent: Custom strings
└── Affiliate ID: In config/ransom note
```

### Cl0p Ransomware

```
CL0P PROFILE:
├── Status: Highly active, focus on mass exploitation
├── Model: Extortion-focused (encryption sometimes optional)
├── Language: C++
├── Platforms: Windows primarily
├── Notable: MOVEit, GoAnywhere, Accellion exploits
├── Extension: .Cl0p, .C_L_O_P, .CIIp
├── Ransom Note: ClopReadMe.txt, readme!!!.txt

TECHNICAL CHARACTERISTICS:
├── Supply chain exploitation focus
├── Zero-day exploitation (MOVEit CVE-2023-34362)
├── Mass data theft prioritized over encryption
├── Language check (Russia/CIS avoidance)
├── Terminates database and backup processes
├── Kills security software processes
├── Certificate validation bypass
└── Direct extortion without encryption increasingly common

DETECTION INDICATORS:
├── Exploitation: MOVEit, GoAnywhere, Accellion
├── File: ClopReadMe.txt, readme!!!.txt
├── Extension: .Cl0p variants
├── Process: Terminates specific processes
├── Behavior: Mass file exfiltration before encryption
├── Network: Large outbound data transfers
├── Commands:
│   ├── Process termination list (100+ processes)
│   ├── Service termination
│   └── Shadow deletion (standard)

EXPLOITATION TIMELINE (2023-2024):
├── Accellion FTA (Dec 2020 - Feb 2021)
├── SolarWinds Serv-U (2021)
├── GoAnywhere MFT (Jan-Feb 2023)
├── PaperCut (Apr 2023)
├── MOVEit Transfer (May-Jun 2023) - 2000+ orgs affected
└── Continued zero-day focus

YARA SIGNATURE:
rule Clop_Ransomware {
    strings:
        $note1 = "ClopReadMe" ascii wide nocase
        $note2 = "CLOP" ascii wide
        $ext1 = ".Cl0p" ascii
        $ext2 = ".C_L_O_P" ascii
        $lang_check = "GetUserDefaultLangID" ascii
        $av_term = "taskkill /f /im" ascii
    condition:
        uint16(0) == 0x5A4D and 3 of them
}
```

### Play Ransomware

```
PLAY PROFILE:
├── Status: Emerged June 2022, consistent activity
├── Model: Closed group (not RaaS initially, limited RaaS now)
├── Language: C++
├── Platforms: Windows, ESXi
├── Encryption: AES-RSA hybrid, intermittent encryption
├── Extension: .play
├── Ransom Note: ReadMe.txt

TECHNICAL CHARACTERISTICS:
├── Intermittent encryption (faster, partial file encryption)
├── Uses SystemBC, Cobalt Strike for access
├── Exploits FortiOS, Microsoft Exchange (ProxyNotShell)
├── AdFind for AD enumeration
├── GMER for AV/EDR disabling
├── Rclone for data exfiltration
├── Custom tools for credential dumping
└── Healthcare sector targeting

DETECTION INDICATORS:
├── Extension: .PLAY
├── Note: ReadMe.txt (simple format)
├── Tools: AdFind, GMER, Rclone, SystemBC
├── Exploits: FortiOS, Exchange
├── Process: Task termination before encryption
├── Lateral: WMI, PsExec
├── Commands:
│   ├── wmic shadowcopy delete
│   ├── vssadmin delete shadows /all /quiet
│   └── Disables Windows Defender

ATTACK CHAIN:
1. Initial Access: Exploit (FortiOS, Exchange) or valid credentials
2. Discovery: AdFind, BloodHound
3. Defense Evasion: GMER to disable security
4. Credential Access: Mimikatz, custom tools
5. Lateral Movement: WMI, PsExec, RDP
6. Collection: Archive sensitive data
7. Exfiltration: Rclone to cloud storage
8. Impact: Deploy Play ransomware

YARA SIGNATURE:
rule Play_Ransomware {
    strings:
        $ext = ".PLAY" ascii wide
        $note = "ReadMe.txt" ascii wide
        $s1 = "Your files have been encrypted" ascii wide nocase
        $s2 = "play" ascii wide nocase
    condition:
        uint16(0) == 0x5A4D and ($ext or $note) and any of ($s*)
}
```

### Royal Ransomware

```
ROYAL PROFILE:
├── Status: Emerged Sept 2022, rebranded to BlackSuit 2023
├── Model: Private group (no RaaS)
├── Language: C++
├── Platforms: Windows, Linux (ESXi)
├── Encryption: AES-256 (OpenSSL) + RSA
├── Extension: .royal
├── Ransom Note: README.TXT

TECHNICAL CHARACTERISTICS:
├── Callback phishing (BazarCall technique)
├── Partial/intermittent encryption options
├── Percentage-based encryption (configurable)
├── Uses legitimate tools (NSudo, PCHunter)
├── Disables security via BYOVD
├── Targets large enterprises
├── Conti lineage connections
└── Custom per-victim configuration

DETECTION INDICATORS:
├── Extension: .royal
├── Note: README.TXT
├── Initial Access: Callback phishing → remote access
├── Tools: Cobalt Strike, NSudo, PCHunter
├── Process: Terminates processes/services
├── Network: Tor-based communication
├── Commands:
│   ├── vssadmin delete shadows /all /quiet
│   ├── wmic shadowcopy delete
│   ├── bcdedit /set recoveryenabled no
│   └── Uses BYOVD for security bypass

CALLBACK PHISHING FLOW:
1. Victim receives fake invoice/subscription email
2. Email contains phone number (not link)
3. Victim calls "support"
4. Operator instructs to install remote access tool
5. Operator deploys Royal ransomware
6. Files encrypted, ransom demanded

YARA SIGNATURE:
rule Royal_Ransomware {
    strings:
        $ext = ".royal" ascii wide
        $note = "README.TXT" ascii wide
        $s1 = "your files are encrypted" ascii wide nocase
        $s2 = "royal" ascii wide nocase
        $openssl = "OpenSSL" ascii
    condition:
        uint16(0) == 0x5A4D and 3 of them
}
```

### Akira Ransomware

```
AKIRA PROFILE:
├── Status: Emerged March 2023, very active
├── Model: RaaS
├── Language: C++ (Windows), Rust (Linux)
├── Platforms: Windows, Linux (ESXi)
├── Encryption: ChaCha20 + RSA-4096
├── Extension: .akira
├── Ransom Note: akira_readme.txt
├── Notable: Retro 1980s terminal aesthetic

TECHNICAL CHARACTERISTICS:
├── Exploits Cisco VPN vulnerabilities
├── Uses compromised VPN credentials
├── Conti code connections
├── PowerShell for deployment
├── WMI for lateral movement
├── Terminates backup/AV processes
├── Linux variant for ESXi
├── Retro-themed leak site
└── Targets SMB and enterprise

DETECTION INDICATORS:
├── Extension: .akira
├── Note: akira_readme.txt
├── Leak Site: Retro terminal UI
├── Initial Access: Cisco VPN exploits, valid credentials
├── Tools: Mimikatz, LaZagne, Cobalt Strike
├── Behavior: Process termination, shadow deletion
├── Commands:
│   ├── vssadmin delete shadows /all /quiet
│   ├── PowerShell encoded commands
│   └── Service termination

ATTACK CHAIN:
1. Initial Access: Cisco VPN (CVE-2023-20269) or credentials
2. Persistence: Scheduled tasks, services
3. Discovery: PowerShell, built-in Windows tools
4. Credential Access: Mimikatz, LaZagne, LSASS dump
5. Lateral Movement: RDP, WMI, PsExec
6. Collection: Archive with 7-Zip
7. Exfiltration: Cloud storage, SFTP
8. Impact: Akira deployment

YARA SIGNATURE:
rule Akira_Ransomware {
    strings:
        $ext = ".akira" ascii wide
        $note = "akira_readme.txt" ascii wide
        $s1 = "your files are encrypted" ascii wide nocase
        $s2 = "akira" ascii wide nocase
        $s3 = "ChaCha" ascii
    condition:
        uint16(0) == 0x5A4D and 3 of them
}
```

### Black Basta Ransomware

```
BLACK BASTA PROFILE:
├── Status: Emerged April 2022, Conti successor
├── Model: Private (selective RaaS)
├── Language: C++
├── Platforms: Windows, Linux (ESXi)
├── Encryption: ChaCha20 + RSA-4096
├── Extension: .basta
├── Ransom Note: readme.txt

TECHNICAL CHARACTERISTICS:
├── Conti member origins (disbanding aftermath)
├── QakBot, Pikabot for initial delivery
├── Cobalt Strike for post-exploitation
├── Uses PrintNightmare, ZeroLogon exploits
├── SystemBC for persistence
├── Mimikatz for credentials
├── Rclone for exfiltration
├── Large enterprise targeting
└── Highly selective victim choice

DETECTION INDICATORS:
├── Extension: .basta
├── Note: readme.txt
├── Initial Access: QakBot/Pikabot, phishing
├── Tools: Cobalt Strike, SystemBC, Mimikatz, Rclone
├── Exploits: PrintNightmare, ZeroLogon
├── Wallpaper: Changes desktop to ransom message
├── Commands:
│   ├── vssadmin delete shadows /all /quiet
│   ├── bcdedit /set safeboot network
│   ├── Reboots to safe mode for encryption
│   └── Uses BYOVD for EDR bypass

ATTACK CHAIN:
1. Initial Access: QakBot via phishing email
2. Execution: Cobalt Strike beacon deployment
3. Persistence: SystemBC, scheduled tasks
4. Credential Access: Mimikatz, LSASS dump
5. Discovery: AdFind, nltest, BloodHound
6. Lateral Movement: PsExec, WMI, RDP
7. Collection: Sensitive file identification
8. Exfiltration: Rclone to cloud storage
9. Defense Evasion: Boot to safe mode
10. Impact: Black Basta deployment

YARA SIGNATURE:
rule BlackBasta_Ransomware {
    strings:
        $ext = ".basta" ascii wide
        $note = "readme.txt" ascii wide
        $s1 = "black basta" ascii wide nocase
        $s2 = "ChaCha20" ascii
        $s3 = "your data has been stolen" ascii wide nocase
        $icon = { 00 00 01 00 01 00 }  // Icon resource
    condition:
        uint16(0) == 0x5A4D and 3 of them
}
```

### Ransomware Comparison Matrix

```
┌──────────────┬──────────┬─────────────┬──────────────┬───────────────────────┬────────────────────┐
│ Family       │ Language │ Encryption  │ Extension    │ Primary Vector        │ Key Characteristic │
├──────────────┼──────────┼─────────────┼──────────────┼───────────────────────┼────────────────────┤
│ LockBit 3.0  │ C/C++    │ AES+RSA     │ .lockbit     │ RDP, Phishing, Exploit│ Fastest encryptor  │
│ BlackCat     │ Rust     │ AES+RSA     │ Random(7)    │ Access brokers        │ First Rust ransw.  │
│ Cl0p         │ C++      │ AES+RSA     │ .Cl0p        │ Zero-day exploits     │ Mass exploitation  │
│ Play         │ C++      │ AES+RSA     │ .play        │ Exploits, creds       │ Intermittent enc.  │
│ Royal        │ C++      │ AES+RSA     │ .royal       │ Callback phishing     │ No RaaS model      │
│ Akira        │ C++/Rust │ ChaCha+RSA  │ .akira       │ Cisco VPN exploits    │ Retro aesthetic    │
│ Black Basta  │ C++      │ ChaCha+RSA  │ .basta       │ QakBot/Pikabot        │ Conti successor    │
└──────────────┴──────────┴─────────────┴──────────────┴───────────────────────┴────────────────────┘

RANSOMWARE DWELL TIME (PRE-ENCRYPTION):
├── Minimum: 2 hours (smash-and-grab)
├── Average: 4-14 days (most groups)
├── Maximum: 30+ days (APT-style operations)
└── Time to Encrypt: 45 min - 9 hours (varies by network size)
```

---

## Ransomware Staging Detection (T1490)

### Pre-Encryption Indicators

```
SHADOW COPY DELETION (Most Common):
├── vssadmin.exe delete shadows /all /quiet
├── vssadmin.exe resize shadowstorage /for=C: /on=C: /maxsize=401MB
├── wmic.exe shadowcopy delete
├── wmic.exe shadowcopy delete /nointeractive
├── Get-WmiObject Win32_ShadowCopy | Remove-WmiObject
├── Get-WmiObject Win32_ShadowCopy | ForEach-Object { $_Delete() }
└── PowerShell: gwmi Win32_ShadowCopy | % { $_.Delete() }

BACKUP DESTRUCTION:
├── wbadmin.exe delete catalog -quiet
├── wbadmin.exe delete systemstatebackup -keepversions:0
├── bcdedit.exe /set {default} recoveryenabled No
├── bcdedit.exe /set {default} bootstatuspolicy ignoreallfailures
├── bcdedit.exe /set {globalsettings} advancedoptions false
└── Veeam: Delete backup files, stop services

SECURITY TOOL DISABLING:
├── Windows Defender:
│   ├── Set-MpPreference -DisableRealtimeMonitoring $true
│   ├── Set-MpPreference -DisableIOAVProtection $true
│   ├── Set-MpPreference -DisableBehaviorMonitoring $true
│   ├── reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v DisableAntiSpyware /t REG_DWORD /d 1
│   └── powershell -c "Add-MpPreference -ExclusionPath 'C:\'"
├── Services:
│   ├── net stop WinDefend
│   ├── sc config WinDefend start= disabled
│   ├── net stop MsMpSvc
│   └── taskkill /f /im MsMpEng.exe
├── Firewall:
│   ├── netsh advfirewall set allprofiles state off
│   └── netsh firewall set opmode mode=disable
└── EDR:
    ├── taskkill /f /im <edragent>.exe
    ├── Service manipulation
    └── BYOVD attacks (vulnerable driver loading)

SAFE MODE BOOT (Black Basta technique):
├── bcdedit /set {default} safeboot minimal
├── bcdedit /set {current} safeboot minimal
└── Forces reboot to safe mode (minimal security software)
```

### Detection Queries

```sql
-- SPLUNK: Shadow Copy Deletion Detection
index=windows (source="WinEventLog:Security" OR source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational")
EventCode IN (1, 4688)
| eval CommandLine=coalesce(CommandLine, Process_Command_Line)
| where match(CommandLine, "(?i)(vssadmin.*delete|wmic.*shadowcopy.*delete|bcdedit.*/set.*recoveryenabled|wbadmin.*delete)")
| stats count values(CommandLine) as Commands values(ParentCommandLine) as ParentCommands by Computer, User, _time
| where count > 0
| sort -_time

-- SPLUNK: Backup/Recovery Disabling
index=windows EventCode IN (1, 4688)
| where match(CommandLine, "(?i)(bcdedit.*(recoveryenabled|bootstatuspolicy)|wbadmin.*delete.*catalog)")
| table _time Computer User CommandLine ParentImage

-- SPLUNK: Mass File Encryption Indicators
index=windows EventCode=11  // Sysmon file create
| where match(TargetFilename, "\.(lockbit|encrypted|enc|cry|locked|basta|play|akira|royal)$")
| stats count by Computer, _time span=1m
| where count > 100
| sort -count

-- SPLUNK: Security Tool Tampering
index=windows EventCode IN (1, 4688)
| where match(CommandLine, "(?i)(Set-MpPreference.*Disable|DisableAntiSpyware|net stop.*Defend|sc.*WinDefend)")
| stats count values(CommandLine) as Commands by Computer, User

-- KQL (Microsoft Sentinel): Shadow Copy Deletion
DeviceProcessEvents
| where ProcessCommandLine has_any ("vssadmin", "wmic", "bcdedit", "wbadmin")
| where ProcessCommandLine has_any ("delete", "shadowcopy", "recoveryenabled")
| project Timestamp, DeviceName, InitiatingProcessAccountName, ProcessCommandLine, InitiatingProcessCommandLine

-- KQL: Ransomware Staging Aggregate
let ShadowCopyDeletion = DeviceProcessEvents
    | where ProcessCommandLine has_any ("vssadmin delete", "wmic shadowcopy delete")
    | summarize ShadowDeleteCount=count() by DeviceName, bin(Timestamp, 1h);
let BackupDeletion = DeviceProcessEvents
    | where ProcessCommandLine has_any ("wbadmin delete", "bcdedit /set")
    | summarize BackupDeleteCount=count() by DeviceName, bin(Timestamp, 1h);
let DefenderDisable = DeviceProcessEvents
    | where ProcessCommandLine has_any ("DisableRealtimeMonitoring", "DisableAntiSpyware")
    | summarize DefenderCount=count() by DeviceName, bin(Timestamp, 1h);
ShadowCopyDeletion
| join kind=inner (BackupDeletion) on DeviceName, Timestamp
| join kind=inner (DefenderDisable) on DeviceName, Timestamp
| where ShadowDeleteCount > 0 and BackupDeleteCount > 0 and DefenderCount > 0
```

### Sigma Rules for Ransomware Staging

```yaml
# Shadow Copy Deletion
title: Shadow Copy Deletion via VSSAdmin
id: f6e43c02-9a7f-4e8c-a5b3-d1c8e2345678
status: stable
description: Detects shadow copy deletion commands commonly used by ransomware
author: Security Team
date: 2026/02/24
references:
    - https://attack.mitre.org/techniques/T1490/
logsource:
    category: process_creation
    product: windows
detection:
    selection_vss:
        CommandLine|contains|all:
            - 'vssadmin'
            - 'delete'
            - 'shadows'
    selection_wmic:
        CommandLine|contains|all:
            - 'wmic'
            - 'shadowcopy'
            - 'delete'
    selection_ps:
        CommandLine|contains|all:
            - 'Win32_ShadowCopy'
            - 'Delete'
    condition: selection_vss or selection_wmic or selection_ps
falsepositives:
    - Legitimate administrator activity
    - Backup software operations
level: high
tags:
    - attack.impact
    - attack.t1490

---
# Backup Catalog Deletion
title: Backup Catalog Deletion
id: a7b3d2e1-4c5f-6789-0abc-def123456789
status: stable
description: Detects backup catalog deletion indicating ransomware staging
logsource:
    category: process_creation
    product: windows
detection:
    selection:
        CommandLine|contains|all:
            - 'wbadmin'
            - 'delete'
            - 'catalog'
    condition: selection
level: high
tags:
    - attack.impact
    - attack.t1490

---
# Recovery Options Disabled
title: Recovery Options Disabled via BCDEdit
id: b8c4e3f2-5d6g-7890-1bcd-ef234567890a
status: stable
description: Detects disabling of Windows recovery options
logsource:
    category: process_creation
    product: windows
detection:
    selection_recovery:
        CommandLine|contains|all:
            - 'bcdedit'
            - 'recoveryenabled'
            - 'no'
    selection_bootpolicy:
        CommandLine|contains|all:
            - 'bcdedit'
            - 'bootstatuspolicy'
            - 'ignoreallfailures'
    selection_safeboot:
        CommandLine|contains|all:
            - 'bcdedit'
            - 'safeboot'
    condition: selection_recovery or selection_bootpolicy or selection_safeboot
level: high
tags:
    - attack.impact
    - attack.t1490
    - attack.defense_evasion
    - attack.t1562
```

---

## Ransomware Response Playbook

### Phase 1: Immediate Response (0-30 minutes)

```
TRIAGE CHECKLIST:
□ 1. Establish incident bridge/war room
□ 2. Identify reporter and initial scope
□ 3. Is encryption ACTIVE or COMPLETE?
   ├── Active: IMMEDIATE isolation priority
   └── Complete: Evidence preservation priority
□ 4. Identify affected systems (EDR console, user reports)
□ 5. Identify ransomware variant (extension, note)
□ 6. Notify incident response team leads
□ 7. Engage legal/executive if major incident

IMMEDIATE ISOLATION:
├── EDR: Network isolate affected endpoints
├── Network: Disable switch ports, VLAN isolation
├── Cloud: Remove from network security groups
├── Firewall: Block lateral movement ports (445, 135, 3389)
├── Identity: Disable compromised accounts
└── Shares: Disable file share access if spreading via SMB

DO NOT:
✗ Turn off affected systems (destroys memory evidence)
✗ Delete ransom notes or encrypted files
✗ Run antivirus scans (can encrypt more)
✗ Contact attackers without authorization
✗ Pay ransom without proper process
```

### Phase 2: Assessment (30 min - 2 hours)

```
SCOPE DETERMINATION:
□ Count of affected systems
□ Count of affected users
□ Critical systems impacted?
□ Backup systems status
□ Domain controller status
□ Data exfiltration indicators

EVIDENCE COLLECTION:
□ Memory capture of affected systems (if still on)
   └── winpmem, dumpit, Magnet RAM capture
□ Ransom note collection (all variants)
□ Encrypted file samples
□ Screenshot of ransom portal/instructions
□ Initial access artifacts (phishing email, etc.)
□ Timeline of first encryption (earliest timestamp)

RANSOMWARE IDENTIFICATION:
1. Check ransom note for family indicators
2. Check file extension
3. Upload sample to:
   ├── ID Ransomware (id-ransomware.malwarehunterteam.com)
   ├── No More Ransom (nomoreransom.org)
   └── VirusTotal
4. Check for known decryptors:
   ├── No More Ransom project
   ├── Kaspersky NoRansom
   ├── Emsisoft Decryptors
   └── Avast Decryption Tools

QUESTIONS TO ANSWER:
├── What is the ransomware family/variant?
├── When did encryption start?
├── Is a decryptor available?
├── What was the initial access vector?
├── Are backups intact and clean?
├── Was data exfiltrated?
└── What is the ransom demand?
```

### Phase 3: Containment (2-8 hours)

```
NETWORK CONTAINMENT:
□ Segment affected network areas
□ Block C2 domains/IPs at perimeter
□ Block malicious file hashes
□ Implement SMB restrictions (if spreading via SMB)
□ Disable RDP to/from affected systems
□ Enhanced monitoring on clean systems
□ Identify and protect crown jewels

IDENTITY CONTAINMENT:
□ Force password reset for compromised accounts
□ Disable service accounts used in attack
□ Reset Kerberos tickets (if DC compromised)
□ Review and restrict privileged access
□ Enable enhanced monitoring on admin accounts
□ Consider KRBTGT reset (if severe)

ENDPOINT CONTAINMENT:
□ Deploy IOC blocklist to all endpoints
□ Hunt for staging indicators on clean systems
□ Quarantine systems showing pre-encryption behavior
□ Isolate systems with persistence mechanisms
□ Deploy emergency patches if exploit-based

CONTAINMENT VALIDATION:
□ No new encryptions occurring
□ No new C2 connections
□ No lateral movement detected
□ Affected systems isolated
□ Clean systems protected
```

### Phase 4: Investigation (Parallel with Containment)

```
ROOT CAUSE ANALYSIS:
├── Initial Access Vector
│   ├── Phishing email (obtain sample)
│   ├── RDP brute force (authentication logs)
│   ├── VPN exploit (VPN logs, patch level)
│   ├── Supply chain (third-party access)
│   └── Insider threat (access patterns)
│
├── Attack Timeline Construction
│   ├── First compromise timestamp
│   ├── Lateral movement timeline
│   ├── Credential access events
│   ├── Data staging/exfiltration
│   └── Encryption start timestamp
│
├── Credential Compromise Scope
│   ├── Which accounts compromised?
│   ├── Domain admin access?
│   ├── Service account abuse?
│   └── Credential dumping tools used?
│
└── Data Exfiltration Assessment
    ├── Large outbound transfers?
    ├── Cloud upload indicators?
    ├── Archive tool usage (7z, rar)?
    ├── Rclone, MegaSync usage?
    └── What data was accessed?

INVESTIGATION TOOLS:
├── Velociraptor: Endpoint forensics at scale
├── KAPE: Artifact collection
├── Timeline Explorer: Event correlation
├── Chainsaw: Rapid Windows log analysis
├── Hayabusa: Sigma-based log hunting
└── EDR Console: Historical telemetry
```

### Phase 5: Eradication (After Containment)

```
ERADICATION CHECKLIST:
□ Remove all malware artifacts
□ Remove persistence mechanisms
□ Remove attacker tools
□ Remove compromised accounts
□ Patch exploited vulnerabilities
□ Remove unauthorized access paths
□ Clean or rebuild affected systems

PERSISTENCE REMOVAL:
├── Scheduled tasks
├── Services
├── Registry Run keys
├── Startup folder items
├── WMI subscriptions
├── DLL hijacking
└── Bootkit/MBR infection

SYSTEM DECISIONS:
├── Reimage vs Clean
│   ├── Reimage: Faster, more certain
│   └── Clean: Preserves data, risk of remnants
├── Prioritization
│   ├── Critical business systems first
│   ├── Domain controllers
│   ├── Backup systems
│   └── User workstations last
└── Verification
    ├── Malware scan post-rebuild
    ├── Validate no persistence
    └── Monitor for re-infection
```

### Phase 6: Recovery (After Eradication)

```
RECOVERY PLANNING:
□ Validate backup integrity
□ Test restore process
□ Prioritize recovery order
□ Establish clean network segment
□ Prepare monitoring for recovered systems

BACKUP VERIFICATION:
├── Are backups infected?
│   ├── Check backup timestamps vs infection
│   ├── Scan backup files
│   └── Test restore in isolated environment
├── Are backups complete?
│   ├── Critical data present?
│   ├── System state backups?
│   └── Database backups?
└── Backup system compromise?
    ├── Were backup credentials used?
    ├── Was backup software targeted?
    └── Can backup system be trusted?

RECOVERY EXECUTION:
1. Rebuild/restore in priority order
2. Apply patches before reconnecting
3. Reset all credentials
4. Restore from known-good backups
5. Validate data integrity
6. Monitor heavily during recovery
7. Staged reconnection to network
8. User communication and retraining

RECOVERY WITHOUT BACKUPS:
├── Check for decryptors (No More Ransom)
├── Check shadow copies (if not deleted)
├── Check previous versions
├── Data recovery tools (limited success)
├── Negotiate (legal/executive decision)
└── Accept data loss
```

### Phase 7: Post-Incident (Days-Weeks After)

```
POST-INCIDENT ACTIVITIES:
□ Comprehensive incident report
□ Root cause documentation
□ Lessons learned meeting
□ Security control improvements
□ Detection rule updates
□ Playbook refinement
□ Executive briefing
□ Regulatory notifications (if required)
□ Customer/partner notifications (if required)

IMPROVEMENT AREAS:
├── Detection
│   ├── New detection rules created?
│   ├── Monitoring gaps identified?
│   └── Visibility improvements needed?
├── Prevention
│   ├── Patches to deploy?
│   ├── Configuration changes?
│   └── Architecture improvements?
├── Response
│   ├── Process improvements?
│   ├── Tool gaps identified?
│   └── Training needs?
└── Recovery
    ├── Backup strategy changes?
    ├── DR plan updates?
    └── Recovery testing schedule?

REGULATORY CONSIDERATIONS:
├── GDPR: 72-hour notification requirement
├── HIPAA: Breach notification rules
├── State laws: Varying requirements
├── SEC: Material event disclosure
├── Cyber insurance: Notification requirements
└── Law enforcement: FBI, CISA reporting
```

---

## IOC Types & Quality Hierarchy

### Pyramid of Pain

```
                    ╱╲
                   ╱  ╲
                  ╱    ╲
                 ╱ TTPs ╲         ← Hardest to change, highest value
                ╱________╲
               ╱          ╲
              ╱   Tools    ╲      ← Difficult to change
             ╱______________╲
            ╱                ╲
           ╱  Network/Host   ╲    ← Moderate effort to change
          ╱    Artifacts      ╲
         ╱____________________╲
        ╱                      ╲
       ╱    Domain Names        ╲  ← Easy to change
      ╱__________________________╲
     ╱                            ╲
    ╱      IP Addresses            ╲ ← Very easy to change
   ╱________________________________╲
  ╱                                  ╲
 ╱          Hash Values               ╲ ← Trivial to change
╱______________________________________╲

DETECTION INVESTMENT PRIORITY:
1. TTPs (Behavioral patterns) - Highest ROI
2. Tools (Malware families, frameworks)
3. Artifacts (File paths, registry keys, mutex)
4. Network patterns (C2 protocols, beaconing)
5. Domains (DGA patterns > specific domains)
6. IPs (Useful for blocking, low detection value)
7. Hashes (Baseline, easily evaded)
```

### IOC Categories & Examples

```
ATOMIC INDICATORS (Easily Changed):
├── File Hashes
│   ├── MD5: b1946ac92492d2347c6235b4d2611184 (weak, collisions)
│   ├── SHA1: 0a4d55a8d778e5022fab701977c5d840bbc486d0 (weak)
│   ├── SHA256: a7b9c2d3e4f5... (current standard)
│   └── Usage: Exact match only, any change defeats
├── IP Addresses
│   ├── IPv4: 192.168.1.1
│   ├── IPv6: 2001:0db8:85a3:0000:0000:8a2e:0370:7334
│   └── Usage: Block/alert, easily rotated
├── Domain Names
│   ├── C2: malicious-c2.com
│   ├── Exfil: data-upload.net
│   └── Usage: Block/alert, cheap to register new
├── URLs
│   ├── Full path: http://evil.com/malware/stage2.exe
│   └── Usage: Specific blocking, easily changed
├── Email Addresses
│   ├── Phishing: attacker@malicious.com
│   └── Usage: Block sender, trivial to create new
└── Cryptocurrency Addresses
    ├── Bitcoin: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa
    └── Monero: (for ransom tracking)

COMPUTED INDICATORS (Moderate Value):
├── Fuzzy Hashes
│   ├── SSDEEP: 3:AXGBicFlgVNhBGcL6wCdw2bA:AXGBicFlgVNhBGcL6wCdw2bA
│   ├── TLSH: T1A712B034679B...
│   └── Usage: Find similar/variant samples
├── Import Hash (imphash)
│   ├── Value: f34d5f2d4577ed6d9ceec516c1f5a744
│   └── Usage: Find related samples (same imports)
├── Rich Header Hash
│   ├── Value: 9a5b8c7d6e4f3a2b1c0d
│   └── Usage: Identify compiler/build environment
├── Certificate Thumbprints
│   ├── Value: SHA256 of code signing cert
│   └── Usage: Track signed malware campaigns
└── YARA Rules
    └── Pattern matching across samples

BEHAVIORAL INDICATORS (High Value):
├── Process Relationships
│   ├── winword.exe → cmd.exe → powershell.exe
│   └── explorer.exe → malware.exe
├── Command Line Patterns
│   ├── powershell -enc [base64]
│   ├── certutil -urlcache -split -f
│   └── reg add "HKLM\...\Run"
├── File System Patterns
│   ├── %TEMP%\[random].exe
│   ├── %APPDATA%\Microsoft\[hidden]
│   └── Mass file encryption pattern
├── Registry Patterns
│   ├── Persistence locations
│   ├── Security disabling
│   └── Configuration storage
├── Network Patterns
│   ├── Beaconing interval (60s, 300s)
│   ├── JA3/JA3S fingerprints
│   ├── HTTP header patterns
│   └── DNS query patterns
└── Mutex/Named Objects
    ├── Global\[malware_identifier]
    └── Used for single-instance check

TTP INDICATORS (Highest Value):
├── MITRE ATT&CK Mappings
│   ├── T1055 - Process Injection
│   ├── T1059.001 - PowerShell
│   └── T1490 - Inhibit System Recovery
├── Attack Patterns
│   ├── Callback phishing → Remote access → Ransomware
│   ├── Exploit → Beacon → Lateral → Encrypt
│   └── Credential theft → Domain admin → Mass deploy
└── Behavioral Sequences
    ├── Shadow deletion + AV disable + encryption
    └── Discovery → Staging → Exfil → Encrypt
```

### IOC Quality Assessment

```
IOC QUALITY CRITERIA:
├── Specificity
│   ├── High: Unique to threat actor/campaign
│   ├── Medium: Shared among few threats
│   └── Low: Common/generic (many false positives)
├── Freshness
│   ├── Active: Currently in use
│   ├── Recent: Used in past 30 days
│   └── Historical: Older, may be abandoned
├── Confidence
│   ├── Confirmed: Verified malicious
│   ├── Suspected: Likely malicious
│   └── Unknown: Requires investigation
├── Actionability
│   ├── Blocking: Can be used for prevention
│   ├── Detection: Useful for alerting
│   └── Context: Background information only
└── Source Reliability
    ├── Internal: Your own analysis
    ├── Commercial: Paid threat intel
    ├── OSINT: Open source (verify)
    └── Sharing: ISACs, peer organizations

IOC LIFECYCLE:
1. Collection (intel feeds, analysis, sharing)
2. Validation (verify accuracy, relevance)
3. Enrichment (add context, correlate)
4. Distribution (SIEM, EDR, firewall)
5. Monitoring (track hits, effectiveness)
6. Expiration (age out old indicators)
7. Review (periodic relevance check)
```

---

## YARA Rules Examples

### Ransomware Detection Rules

```yara
rule Ransomware_Generic_Indicators
{
    meta:
        description = "Generic ransomware behavioral indicators"
        author = "Security Team"
        date = "2026-02-24"
        severity = "critical"
        mitre_attack = "T1486"

    strings:
        // Ransom note indicators
        $note1 = "Your files have been encrypted" ascii wide nocase
        $note2 = "bitcoin" ascii wide nocase
        $note3 = "decrypt" ascii wide nocase
        $note4 = "restore your files" ascii wide nocase
        $note5 = "pay the ransom" ascii wide nocase
        $note6 = "cryptocurrency" ascii wide nocase
        $note7 = "your personal key" ascii wide nocase
        $note8 = ".onion" ascii wide

        // Shadow copy deletion
        $shadow1 = "vssadmin.exe delete shadows" ascii wide nocase
        $shadow2 = "vssadmin delete shadows" ascii wide nocase
        $shadow3 = "wmic shadowcopy delete" ascii wide nocase
        $shadow4 = "Win32_ShadowCopy" ascii wide

        // Backup deletion
        $backup1 = "wbadmin delete catalog" ascii wide nocase
        $backup2 = "bcdedit" ascii wide nocase
        $backup3 = "recoveryenabled" ascii wide nocase

        // Crypto operations
        $crypto1 = "CryptEncrypt" ascii
        $crypto2 = "CryptGenKey" ascii
        $crypto3 = "CryptImportKey" ascii
        $crypto4 = "BCryptEncrypt" ascii
        $crypto5 = "AES" ascii
        $crypto6 = "RSA" ascii

    condition:
        uint16(0) == 0x5A4D and
        (
            (3 of ($note*)) or
            (2 of ($shadow*)) or
            (2 of ($backup*)) or
            ((1 of ($shadow*) or 1 of ($backup*)) and 2 of ($crypto*))
        )
}

rule LockBit_Ransomware
{
    meta:
        description = "LockBit ransomware family detection"
        author = "Security Team"
        date = "2026-02-24"
        malware_family = "LockBit"

    strings:
        $s1 = "LockBit" ascii wide nocase
        $s2 = ".lockbit" ascii wide
        $s3 = "Restore-My-Files.txt" ascii wide
        $s4 = "http://lockbit" ascii wide

        // Mutex patterns
        $mutex1 = "Global\\" ascii wide

        // Config in resource
        $cfg = { 4C 6F 63 6B 42 69 74 }

        // StealBit indicators
        $steal1 = "StealBit" ascii wide

    condition:
        uint16(0) == 0x5A4D and 3 of them
}

rule BlackCat_ALPHV_Ransomware
{
    meta:
        description = "BlackCat/ALPHV ransomware (Rust-based)"
        author = "Security Team"
        date = "2026-02-24"
        malware_family = "BlackCat"

    strings:
        // Rust artifacts
        $rust1 = "rust_panic" ascii
        $rust2 = "_ZN" ascii  // Rust mangled names
        $rust3 = ".rdata$zzzz" ascii

        // BlackCat specific
        $s1 = "access-token" ascii wide
        $s2 = "RECOVER-" ascii wide
        $s3 = "-FILES.txt" ascii wide
        $s4 = "\"config\"" ascii
        $s5 = "esxi" ascii wide

        // Extension pattern
        $ext = /\.[a-z0-9]{7}/ ascii

    condition:
        uint16(0) == 0x5A4D and
        2 of ($rust*) and 2 of ($s*)
}

rule Akira_Ransomware
{
    meta:
        description = "Akira ransomware detection"
        author = "Security Team"
        date = "2026-02-24"
        malware_family = "Akira"

    strings:
        $s1 = ".akira" ascii wide
        $s2 = "akira_readme.txt" ascii wide
        $s3 = "akira" ascii wide nocase
        $s4 = "ChaCha" ascii
        $s5 = "retro" ascii wide nocase

        // Rust variant indicators (Linux)
        $rust = "rust_panic" ascii

    condition:
        (uint16(0) == 0x5A4D or uint32(0) == 0x464c457f) and
        3 of ($s*)
}
```

### Cobalt Strike Detection

```yara
rule CobaltStrike_Beacon_Generic
{
    meta:
        description = "Cobalt Strike Beacon indicators"
        author = "Security Team"
        date = "2026-02-24"
        threat_type = "post-exploitation"

    strings:
        // Common beacon strings
        $s1 = "beacon.dll" ascii
        $s2 = "beacon.x64.dll" ascii
        $s3 = "%02d/%02d/%02d %02d:%02d:%02d" ascii
        $s4 = "%s as %s\\%s: %d" ascii
        $s5 = "ReflectiveLoader" ascii
        $s6 = "MSSE-%d-server" ascii

        // Default named pipes
        $pipe1 = "\\\\.\\pipe\\msagent_" ascii wide
        $pipe2 = "\\\\.\\pipe\\MSSE-" ascii wide
        $pipe3 = "\\\\.\\pipe\\status_" ascii wide
        $pipe4 = "\\\\.\\pipe\\postex_" ascii wide

        // Malleable C2 defaults
        $c2_1 = "/submit.php" ascii
        $c2_2 = "/pixel" ascii
        $c2_3 = "Cookie: " ascii
        $c2_4 = "__cfduid=" ascii

        // Shellcode patterns
        $shell1 = { FC E8 ?? 00 00 00 }  // Call next instruction
        $shell2 = { 4D 5A 41 52 55 48 89 E5 }  // MZ header in shellcode

    condition:
        uint16(0) == 0x5A4D and
        (3 of ($s*) or 2 of ($pipe*) or 2 of ($c2*) or any of ($shell*))
}

rule CobaltStrike_Beacon_Config
{
    meta:
        description = "Cobalt Strike encoded configuration"

    strings:
        // Config markers
        $config_marker = { 00 01 00 01 00 02 }

        // XOR encoded config patterns
        $xor_config = { 69 68 69 68 69 6B }

        // Watermark patterns (license tracking)
        $watermark = { 00 00 00 00 ?? ?? ?? ?? 00 00 00 00 }

    condition:
        uint16(0) == 0x5A4D and
        any of them
}
```

### Info Stealer Detection

```yara
rule InfoStealer_Browser_Credentials
{
    meta:
        description = "Info stealer targeting browser credentials"
        author = "Security Team"
        date = "2026-02-24"

    strings:
        // Browser paths
        $chrome = "\\Google\\Chrome\\User Data\\Default\\Login Data" ascii wide
        $firefox = "\\Mozilla\\Firefox\\Profiles" ascii wide
        $edge = "\\Microsoft\\Edge\\User Data\\Default\\Login Data" ascii wide

        // Browser databases
        $db1 = "logins.json" ascii wide
        $db2 = "Login Data" ascii wide
        $db3 = "cookies.sqlite" ascii wide
        $db4 = "key3.db" ascii wide
        $db5 = "key4.db" ascii wide

        // Crypto wallet paths
        $wallet1 = "\\Ethereum\\keystore" ascii wide
        $wallet2 = "\\Bitcoin\\wallet.dat" ascii wide
        $wallet3 = "\\Exodus\\exodus.wallet" ascii wide
        $wallet4 = "\\Electrum\\wallets" ascii wide

        // Credential extraction functions
        $func1 = "CryptUnprotectData" ascii
        $func2 = "BCrypt" ascii
        $func3 = "sqlite3" ascii

    condition:
        uint16(0) == 0x5A4D and
        (3 of ($chrome, $firefox, $edge, $db*) or 2 of ($wallet*)) and
        any of ($func*)
}

rule InfoStealer_Clipboard_Keylogger
{
    meta:
        description = "Info stealer with clipboard/keylogging capability"

    strings:
        // Keylogging APIs
        $key1 = "GetAsyncKeyState" ascii
        $key2 = "SetWindowsHookExA" ascii
        $key3 = "GetKeyboardState" ascii
        $key4 = "WH_KEYBOARD" ascii
        $key5 = "WH_KEYBOARD_LL" ascii

        // Clipboard APIs
        $clip1 = "GetClipboardData" ascii
        $clip2 = "OpenClipboard" ascii
        $clip3 = "SetClipboardViewer" ascii

        // Screenshot APIs
        $screen1 = "BitBlt" ascii
        $screen2 = "GetDC" ascii
        $screen3 = "CreateCompatibleBitmap" ascii

    condition:
        uint16(0) == 0x5A4D and
        (2 of ($key*) or 2 of ($clip*) or all of ($screen*))
}
```

### Process Injection Detection

```yara
rule Process_Injection_Indicators
{
    meta:
        description = "Process injection technique indicators"
        author = "Security Team"
        date = "2026-02-24"
        mitre_attack = "T1055"

    strings:
        // Memory allocation in remote process
        $alloc1 = "VirtualAllocEx" ascii
        $alloc2 = "NtAllocateVirtualMemory" ascii

        // Write to remote process
        $write1 = "WriteProcessMemory" ascii
        $write2 = "NtWriteVirtualMemory" ascii

        // Remote thread creation
        $thread1 = "CreateRemoteThread" ascii
        $thread2 = "NtCreateThreadEx" ascii
        $thread3 = "RtlCreateUserThread" ascii

        // Process hollowing
        $hollow1 = "NtUnmapViewOfSection" ascii
        $hollow2 = "ZwUnmapViewOfSection" ascii

        // APC injection
        $apc1 = "QueueUserAPC" ascii
        $apc2 = "NtQueueApcThread" ascii

        // Thread context manipulation
        $ctx1 = "SetThreadContext" ascii
        $ctx2 = "GetThreadContext" ascii
        $ctx3 = "NtSetContextThread" ascii

        // Process handle
        $proc1 = "OpenProcess" ascii
        $proc2 = "NtOpenProcess" ascii

    condition:
        uint16(0) == 0x5A4D and
        1 of ($proc*) and
        1 of ($alloc*) and
        1 of ($write*) and
        (1 of ($thread*) or 1 of ($hollow*) or 1 of ($apc*) or 1 of ($ctx*))
}
```

---

## Malware Analysis Workflow

### Complete Analysis Process

```
PHASE 1: INITIAL TRIAGE (5-15 minutes)
├── 1.1 Evidence Handling
│   ├── Record source and chain of custody
│   ├── Calculate file hashes (SHA256, MD5)
│   ├── Store original in secure location
│   └── Work only with copies
│
├── 1.2 Quick Classification
│   ├── Check hashes against VirusTotal
│   ├── Check internal malware database
│   ├── Check threat intel platforms (MISP, OTX)
│   └── Decision: Known vs Unknown
│
├── 1.3 File Type Verification
│   ├── file command / TrID
│   ├── Magic bytes verification
│   ├── Extension vs actual type
│   └── Packer detection (DIE, PEiD)
│
└── 1.4 Quick Strings Analysis
    ├── strings / FLOSS extraction
    ├── Look for obvious IOCs
    └── Initial capability assessment

PHASE 2: STATIC ANALYSIS (30-90 minutes)
├── 2.1 PE Analysis (if Windows executable)
│   ├── Headers (compile time, entry point)
│   ├── Sections (entropy, permissions)
│   ├── Imports (suspicious APIs)
│   ├── Exports (if DLL)
│   ├── Resources (embedded files, configs)
│   └── Digital signature verification
│
├── 2.2 Deep String Analysis
│   ├── FLOSS for obfuscated strings
│   ├── Extract URLs, IPs, domains
│   ├── Identify file paths, registry keys
│   ├── Find embedded commands
│   └── Look for configuration data
│
├── 2.3 Packing/Obfuscation Assessment
│   ├── Identify packer/cryptor
│   ├── Entropy analysis
│   ├── Attempt automated unpacking
│   └── Plan for manual unpacking if needed
│
├── 2.4 YARA Matching
│   ├── Run against signature database
│   ├── Identify family/campaign
│   └── Note matching rules
│
└── 2.5 Initial Report
    ├── File metadata
    ├── Suspected capabilities
    ├── Family identification
    └── Go/no-go for dynamic analysis

PHASE 3: DYNAMIC ANALYSIS (1-4 hours)
├── 3.1 Environment Preparation
│   ├── Configure isolated VM
│   ├── Set up network capture (FakeNet/INetSim)
│   ├── Install monitoring tools
│   ├── Create clean snapshot
│   └── Configure anti-evasion countermeasures
│
├── 3.2 Monitored Execution
│   ├── Start all monitoring tools
│   ├── Execute sample
│   ├── Monitor process activity
│   ├── Monitor file system changes
│   ├── Monitor registry changes
│   ├── Monitor network activity
│   └── Record all behaviors
│
├── 3.3 Extended Execution
│   ├── Wait for time-based triggers
│   ├── Simulate user activity
│   ├── Test different network conditions
│   ├── Try different execution arguments
│   └── Reboot and observe persistence
│
├── 3.4 Network Analysis
│   ├── Identify C2 communication
│   ├── Analyze protocols used
│   ├── Extract additional IOCs
│   └── Identify data exfiltration
│
└── 3.5 Behavioral Summary
    ├── Process tree
    ├── File changes
    ├── Registry changes
    ├── Network connections
    └── Persistence mechanisms

PHASE 4: CODE ANALYSIS (2-16 hours, if needed)
├── 4.1 Unpacking (if packed)
│   ├── Automated unpacking attempt
│   ├── Manual unpacking if needed
│   ├── Memory dump at OEP
│   └── IAT reconstruction
│
├── 4.2 Disassembly Review
│   ├── Load in Ghidra/IDA
│   ├── Auto-analysis
│   ├── Identify entry points
│   ├── Rename functions as understood
│   └── Add comments and annotations
│
├── 4.3 Focus Areas
│   ├── C2 communication protocol
│   ├── Encryption/decryption routines
│   ├── Anti-analysis techniques
│   ├── Payload decoding
│   └── Configuration extraction
│
├── 4.4 Algorithm Identification
│   ├── Crypto constants (FindCrypt)
│   ├── Hashing algorithms
│   ├── Encoding schemes
│   └── Custom algorithms
│
└── 4.5 Complete Understanding
    ├── Full capability mapping
    ├── All IOCs extracted
    ├── Detection opportunities identified
    └── Decryptor possibility assessment

PHASE 5: REPORTING (1-2 hours)
├── 5.1 IOC Extraction
│   ├── File indicators (hashes, names, paths)
│   ├── Network indicators (IPs, domains, URLs)
│   ├── Host indicators (registry, services, tasks)
│   └── Behavioral indicators (process patterns)
│
├── 5.2 MITRE ATT&CK Mapping
│   ├── Identify all techniques used
│   ├── Map to tactics
│   └── Note detection opportunities
│
├── 5.3 Detection Signatures
│   ├── YARA rules
│   ├── Sigma rules
│   ├── SIEM queries
│   └── Network signatures (Snort/Suricata)
│
├── 5.4 Technical Report
│   ├── Executive summary
│   ├── File information
│   ├── Behavioral analysis
│   ├── Technical details
│   ├── IOCs (structured format)
│   └── Mitigation recommendations
│
└── 5.5 Intelligence Sharing
    ├── Update internal databases
    ├── Share via ISACs
    ├── Update threat intel platform
    └── Contribute to community (if appropriate)
```

### Analysis Decision Tree

```
START: Received suspicious file
    │
    ├─► Hash lookup (VT, internal)
    │       │
    │       ├─► Known malware → Report, extract IOCs, done
    │       │
    │       └─► Unknown → Continue analysis
    │
    ├─► File type check
    │       │
    │       ├─► Executable (PE, ELF, Mach-O) → Full analysis
    │       │
    │       ├─► Document (Office, PDF) → Macro/exploit analysis
    │       │
    │       ├─► Script (PS1, VBS, JS) → Script analysis
    │       │
    │       └─► Archive → Extract and recurse
    │
    ├─► Packing check
    │       │
    │       ├─► Not packed → Proceed to static analysis
    │       │
    │       └─► Packed → Attempt unpacking or proceed to dynamic
    │
    ├─► Quick static analysis
    │       │
    │       ├─► Clear capability identified → Proceed to dynamic
    │       │
    │       └─► Heavily obfuscated → Proceed to dynamic, plan code analysis
    │
    ├─► Dynamic analysis
    │       │
    │       ├─► Behaviors observed → Document and correlate
    │       │
    │       └─► No activity → Anti-analysis? Try different conditions
    │
    ├─► Code analysis (if needed)
    │       │
    │       ├─► C2 protocol understood
    │       │
    │       ├─► Encryption algorithm identified
    │       │
    │       └─► Full capability mapped
    │
    └─► FINAL: Report, IOCs, signatures, share intelligence
```

---

## Interview Questions - Malware/Ransomware

### Foundational Questions

**1. Walk me through how you would safely analyze a suspicious malware sample.**

```
EXPECTED ANSWER STRUCTURE:
1. Evidence handling
   - Record source, calculate hashes, preserve original
   - Work only with copies

2. Environment setup
   - Isolated VM with snapshot
   - No network or controlled network (FakeNet/INetSim)
   - Monitoring tools installed (ProcMon, Wireshark)

3. Initial triage
   - Hash lookup (VirusTotal, internal)
   - File type verification
   - Quick strings analysis

4. Static analysis
   - PE analysis (if Windows)
   - Import analysis for capability assessment
   - YARA scanning

5. Dynamic analysis
   - Controlled execution with monitoring
   - Capture process, file, registry, network activity
   - Test different conditions

6. Code analysis (if needed)
   - Unpacking if packed
   - Disassembly/decompilation
   - Focus on C2, encryption, persistence

7. Reporting
   - IOC extraction
   - MITRE mapping
   - Detection signatures
```

**2. What's the difference between static and dynamic analysis? When would you use each?**

```
STATIC ANALYSIS:
- No execution of the sample
- Examine code, structure, strings
- Pros: Safe, fast, complete view
- Cons: Obfuscation defeats it, may miss runtime behavior
- Use when: Initial triage, packed samples, determining if dynamic is safe

DYNAMIC ANALYSIS:
- Execute in controlled environment
- Observe actual behavior
- Pros: See real activity, bypass obfuscation
- Cons: May not trigger all behaviors, requires isolation
- Use when: Obfuscated samples, need behavioral IOCs, C2 identification

BEST PRACTICE:
- Always start with static
- Use static to inform dynamic setup
- Dynamic fills gaps static can't see
- Code analysis for deep understanding
```

**3. How do you identify if a PE file is packed? How would you unpack it?**

```
PACKING INDICATORS:
1. High entropy (>7.0) in sections
2. Few or no imports
3. Only LoadLibrary/GetProcAddress imports
4. Unusual section names (UPX, .vmp, .themida)
5. Small code section, large other sections
6. Entry point outside typical .text
7. Packer signatures (PEiD, DIE, Exeinfo PE)

UNPACKING APPROACHES:
1. Automated tools
   - upx -d for UPX
   - Specific unpacker tools

2. Manual unpacking
   - Load in debugger (x64dbg)
   - Find Original Entry Point (OEP)
   - ESP trick, memory breakpoints
   - Dump memory at OEP
   - Rebuild IAT with Scylla/ImpREC

3. Memory dump during execution
   - Let it unpack itself
   - Dump from memory with PE-sieve
   - May need to fix headers
```

### Scenario-Based Questions

**4. You receive an alert that a user's machine is encrypting files rapidly. Walk me through your response.**

```
IMMEDIATE (0-5 minutes):
1. Confirm alert (check EDR for file activity pattern)
2. Network isolate the endpoint immediately
3. Identify user and business impact
4. Check if encryption is ongoing or complete

ASSESSMENT (5-30 minutes):
1. Identify ransomware variant (extension, ransom note)
2. Determine scope (other affected systems?)
3. Check for lateral movement indicators
4. Preserve evidence (don't reboot if possible)

CONTAINMENT:
1. Block IOCs across environment
2. Check other endpoints for staging indicators
3. Disable affected user accounts
4. Implement network segmentation

INVESTIGATION:
1. Identify initial access vector
2. Build attack timeline
3. Determine data exfiltration
4. Full scope assessment

RECOVERY:
1. Check for decryptor availability
2. Validate backup integrity
3. Plan recovery prioritization
4. Execute recovery with monitoring
```

**5. How would you detect ransomware staging before encryption occurs?**

```
PRE-ENCRYPTION INDICATORS:

1. Shadow copy deletion
   - vssadmin delete shadows
   - wmic shadowcopy delete
   - Sigma/SIEM rule on these commands

2. Backup destruction
   - wbadmin delete catalog
   - bcdedit recoveryenabled no
   - Targeting backup software

3. Security tool tampering
   - Windows Defender disabled
   - Endpoint agent stopped
   - Firewall modifications

4. Reconnaissance
   - AdFind, BloodHound usage
   - Mass file share enumeration
   - Domain trust mapping

5. Credential theft
   - Mimikatz indicators
   - LSASS access
   - Kerberoasting

6. Data staging
   - 7-Zip/RAR large archives
   - Unusual cloud uploads
   - Rclone usage

DETECTION APPROACH:
- Behavioral rules for staging commands
- Process lineage analysis
- Volume of sensitive file access
- Network anomalies (large transfers)
- Correlation of multiple weak signals
```

**6. Explain how you would reverse engineer a ransomware sample's encryption to determine if decryption is possible.**

```
ENCRYPTION ANALYSIS APPROACH:

1. Static analysis
   - Identify crypto APIs (CryptEncrypt, BCrypt*, OpenSSL)
   - Look for crypto constants (AES S-box, RSA constants)
   - Find key generation functions
   - Identify key storage/transmission

2. Dynamic analysis
   - Monitor crypto API calls
   - Capture keys in memory
   - Observe key handling

3. Code analysis
   - Reverse the encryption routine
   - Identify algorithm (AES, ChaCha, RSA)
   - Determine key derivation method
   - Check for implementation flaws

DECRYPTION POSSIBILITY:

Possible if:
- Hardcoded or predictable key
- Key stored locally
- Weak RNG for key generation
- Implementation bugs
- ECB mode (pattern analysis)
- Key derivation flaws

Not possible if:
- Proper hybrid encryption (AES + RSA)
- Key sent to C2 and deleted
- Strong RNG
- Correct implementation

EXAMPLES OF FLAWED RANSOMWARE:
- Using current time as seed (predictable)
- Storing key in memory after encryption
- Using same key for all files
- ECB mode leaking patterns
```

### Advanced Questions

**7. How do you differentiate between similar ransomware families? What artifacts would you compare?**

```
DIFFERENTIATION ARTIFACTS:

1. Code-level
   - Compiler and version
   - Build environment (Rich header)
   - Code patterns and algorithms
   - Error strings and debug artifacts

2. Behavioral
   - Encryption algorithm and mode
   - File extension pattern
   - Ransom note format and content
   - Persistence mechanisms
   - Anti-analysis techniques

3. Network
   - C2 protocol
   - Beacon patterns
   - Tor usage
   - Exfiltration methods

4. Structural
   - PE characteristics
   - Import hash (imphash)
   - Fuzzy hash (SSDEEP)
   - Resource patterns

FAMILY ATTRIBUTION:
- Code reuse from leaked source (Conti, LockBit)
- Similar TTPs and tooling
- Infrastructure overlap
- Operational patterns
- Ransom negotiation behavior
```

**8. Describe how you would create detection content for a new ransomware variant you've just analyzed.**

```
DETECTION CONTENT CREATION:

1. IOC-based (Quick deployment)
   - File hashes (SHA256)
   - Known domains/IPs
   - File names and paths
   - Registry keys

2. YARA rules
   - Unique strings
   - Code patterns
   - PE characteristics
   - Ransom note indicators

3. Sigma rules
   - Process creation patterns
   - Command line indicators
   - Staging behavior
   - Persistence methods

4. SIEM queries
   - Correlate multiple indicators
   - Behavioral patterns
   - Anomaly detection

5. EDR detections
   - Behavioral rules
   - Memory indicators
   - API patterns
   - File operation patterns

VALIDATION:
- Test against known samples
- Check for false positives
- Deploy in detection-only mode first
- Monitor effectiveness
- Tune as needed

EXAMPLE SIGMA:
title: New_Ransomware_Variant_X
logsource:
    category: process_creation
    product: windows
detection:
    selection:
        CommandLine|contains:
            - 'variant_specific_pattern'
            - 'unique_argument'
    condition: selection
```

**9. How would you approach analyzing a Rust-based or Go-based malware sample differently than traditional C/C++ malware?**

```
RUST/GO ANALYSIS CHALLENGES:

1. Large binary size
   - Statically linked runtime
   - Many embedded functions
   - Longer analysis time

2. Different function conventions
   - Non-standard calling conventions
   - Complex parameter passing
   - Struct returns

3. Symbol stripping
   - Often stripped
   - Need symbol recovery techniques
   - Community signature databases

4. Decompiler limitations
   - Ghidra/IDA may struggle
   - Requires manual annotation
   - Specialized plugins help

APPROACHES:

For Rust:
- Use rust-analyzer for demangling
- Look for panic handlers
- Identify Rust standard library
- Focus on business logic
- Use Ghidra with Rust analysis plugins

For Go:
- Use GoReSym for symbol recovery
- Identify runtime functions
- Look for goroutine patterns
- Use IDAGolangHelper
- Focus on main package

GENERAL STRATEGY:
- Dynamic analysis more valuable
- Focus on APIs called, not implementation
- Look for configuration strings
- Network analysis for C2
- Behavioral analysis for capability
```

**10. Your organization has been hit by ransomware. The CEO asks: "Should we pay?" How do you advise?**

```
CONSIDERATIONS AGAINST PAYING:
1. No guarantee of decryption
2. May receive broken decryptor
3. Funds criminal operations
4. May violate sanctions (OFAC)
5. Makes organization a repeat target
6. Data may already be leaked
7. May face legal/regulatory issues

CONSIDERATIONS FOR PAYING:
1. Business continuity critical
2. No viable backups
3. Cost of downtime exceeds ransom
4. Decryption only way to recover

ADVISORY FRAMEWORK:

1. Assess alternatives first
   - Backup availability and integrity
   - Decryptor availability (No More Ransom)
   - Shadow copy recovery
   - Rebuild feasibility

2. If considering payment
   - Engage law enforcement (FBI, CISA)
   - Check sanctions lists (OFAC)
   - Use professional negotiators
   - Get legal counsel
   - Document everything

3. Decision factors
   - Business impact of downtime
   - Data sensitivity and exfiltration
   - Regulatory obligations
   - Insurance coverage
   - Reputational impact

RECOMMENDATION STRUCTURE:
"I recommend we pursue [specific alternative] first.
If that fails, the decision to pay involves [these risks/considerations]
and should be made by [executives/board] with legal counsel,
after consulting law enforcement."
```

---

**Next: [09_WINDOWS_SECURITY.md](./09_WINDOWS_SECURITY.md) -->**
